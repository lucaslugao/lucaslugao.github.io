<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no">
    <title>Tango - @lucaslugao</title>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playwrite+DE+Grund:wght@100..400&display=swap"
        rel="stylesheet">
    <style>
        body {
            font-family: "Playwrite DE Grund", cursive;
            font-optical-sizing: auto;
            font-style: normal;
            text-align: center;
            height: 100dvh;
            margin: 0;
            -webkit-tap-highlight-color: transparent;
            transition: background-color 0.3s ease;
        }

        .game {
            user-select: none;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            height: 100%;

            .controls {
                margin-bottom: 20px;
            }
        }

        body[data-state="solved"] {
            background-color: rgb(216, 245, 255);
        }

        .title {
            font-size: 2em;
            margin: 0;
            color: #000;
        }

        .myname {
            font-size: 0.8em;
            margin-top: 0;
            color: #000;
        }

        .notice {
            opacity: 0;
            margin: 0;
            transition: opacity 0.3s ease;
        }

        body[data-state="solved"] .notice {
            opacity: 1;
        }
    </style>
</head>

<body>
    <div class="game">
        <p class="title">Tango Player</p>
        <p class="myname">by @lucaslugao</p>
        <p class="notice">Solved!</p>
        <div class="controls">
            <button class="undo">Undo</button>
            <button class="clear">Clear</button>
            <button class="redo">Redo</button>
            <button class="confetti">Confetti On</button>
        </div>
    </div>

    <script>
        // This code is licensed under CC-BY-NC 4.0
        // https://creativecommons.org/licenses/by-nc/4.0/

        class BitBuffer {
            constructor(base64String) {
                this.data = Array.from(this.base64ToUint8Array(base64String));
                this.bitIndex = 0;
            }

            base64ToUint8Array(base64String) {
                const binaryString = atob(base64String); //atob decodes base64
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return bytes;
            }

            readBits(numBits) {
                let result = 0;
                let readBits = 0;

                while (numBits > 0) {
                    const byteIndex = Math.floor(this.bitIndex / 8);
                    const bitOffset = this.bitIndex % 8;

                    const availableBits = 8 - bitOffset;
                    const readAmount = Math.min(numBits, availableBits);

                    if (byteIndex >= this.data.length) {
                        return 0;
                    }

                    const mask = (1 << readAmount) - 1;
                    const readVal = (this.data[byteIndex] >> bitOffset) & mask;

                    result |= readVal << readBits;
                    readBits += readAmount;
                    numBits -= readAmount;
                    this.bitIndex += readAmount;
                }

                return result;
            }

            writeBits(value, numBits) {
                value &= (1 << numBits) - 1;

                while (numBits > 0) {
                    const byteIndex = Math.floor(this.bitIndex / 8);
                    const bitOffset = this.bitIndex % 8;

                    if (byteIndex >= this.data.length) {
                        this.data.push(0);
                    }

                    const availableBits = 8 - bitOffset;
                    const writeBits = Math.min(numBits, availableBits);

                    const mask = ((1 << writeBits) - 1) << bitOffset;
                    const writeVal = (value << bitOffset);

                    this.data[byteIndex] = (this.data[byteIndex] & ~mask) | (writeVal & mask);

                    value >>= writeBits;
                    numBits -= writeBits;
                    this.bitIndex += writeBits;
                }
            }

        }
        class MaskedBitset {
            constructor(value = 0, mask = 0) {
                this.value = value;
                this.mask = mask;
            }

            set(k, v) {
                const bit = 1 << k;
                this.value = (this.value & ~bit) | ((-v & bit) >>> 0);
                this.mask |= bit;
            }

            has(k) {
                return (this.mask >> k) & 1 !== 0;
            }

            at(k) {
                return (this.value >> k) & 1;
            }

            get(k) {
                return [this.at(k), this.has(k)];
            }

            delete(k) {
                const bit = 1 << k;
                this.mask &= ~bit;
            }

            allSet() {
                return this.mask === 0b111111;
            }
        }
        class Tango {
            constructor(container, cellSize = 60) {
                this.cellSize = cellSize;
                this.container = container;

                const urlParams = new URLSearchParams(window.location.search);
                this.puzzle = urlParams.get('puzzle');
                if (!this.puzzle) {
                    window.location.search = `?puzzle=CIMgAEAQACAIAAAAAAAQAgAhIQAAAKAQ`;
                    return;
                }

                this.rows = Array(6).fill(null).map(() => new MaskedBitset());
                this.cols = Array(6).fill(null).map(() => new MaskedBitset());
                this.rowsConstr = Array(6).fill(null).map(() => new MaskedBitset());
                this.colsConstr = Array(6).fill(null).map(() => new MaskedBitset());

                const buf = new BitBuffer(this.puzzle);
                for (let k = 0; k < 6; k++) {
                    this.setRow(k, new MaskedBitset(buf.readBits(6), buf.readBits(6)));
                }
                for (let k = 0; k < 6; k++) {
                    this.rowsConstr[k].value = buf.readBits(5);
                    this.rowsConstr[k].mask = buf.readBits(5);
                    this.colsConstr[k].value = buf.readBits(5);
                    this.colsConstr[k].mask = buf.readBits(5);
                }
                this.createBoard();
                this.loadState(decodeURIComponent(window.location.hash.substring(1)));
                this.setCurrent(this.currentState());
                this.history = [];
                this.future = [];

                this.container.appendChild(this.svgElement);

                this.container.querySelector(".undo").addEventListener("click", () => {
                    this.undo();
                });
                this.container.querySelector(".redo").addEventListener("click", () => {
                    this.redo();
                });
                this.container.querySelector(".clear").addEventListener("click", () => {
                    this.clear();
                });

                const confetti = localStorage.getItem("confetti");
                const confettiButton = this.container.querySelector(".confetti");
                this.confetti = true;

                if (confetti) {
                    this.confetti = confetti === "true";
                }
                confettiButton.innerText = this.confetti ? "Confetti On" : "Confetti Off";
                confettiButton.addEventListener("click", () => {
                    this.confetti = !this.confetti;
                    localStorage.setItem("confetti", this.confetti);
                    confettiButton.innerText = this.confetti ? "Confetti On" : "Confetti Off";
                });

                this.hint();
            }


            clear() {
                this.loadState(this.puzzle);
                this.push();
                this.hint();
            }

            set(x, y, c) {
                this.cols[x].set(y, c);
                this.rows[y].set(x, c);
            }

            get(x, y) {
                return this.rows[y].get(x);
            }

            has(x, y) {
                return this.rows[y].has(x);
            }

            delete(x, y) {
                this.rows[y].delete(x);
                this.cols[x].delete(y);
            }

            setRow(y, row) {
                this.rows[y] = row;

                for (let x = 0; x < 6; x++) {
                    const [v, ok] = row.get(x);
                    if (ok) {
                        this.cols[x].set(y, v);
                    }
                }
            }

            loadState(current) {
                if (!current) {
                    return;
                }
                const currentBuf = new BitBuffer(current);
                for (let k = 0; k < 6; k++) {
                    this.setRow(k, new MaskedBitset(currentBuf.readBits(6), currentBuf.readBits(6)));
                }
                for (let y = 0; y < 6; y++) {
                    for (let x = 0; x < 6; x++) {
                        this.updateCell(x, y);
                    }
                }
                this.hint();
            }

            setCurrent(state) {
                this.current = state;
                window.location.hash = encodeURIComponent(this.current);
            }

            currentState() {
                const buf = new BitBuffer("");
                for (let k = 0; k < 6; k++) {
                    const row = this.rows[k];
                    buf.writeBits(row.value, 6);
                    buf.writeBits(row.mask, 6);
                }
                return btoa(String.fromCharCode(...buf.data));
            }

            updateCell(x, y) {
                const cellGroup = this.svgElement.querySelector(`[data-x="${x}"][data-y="${y}"]`);
                const existing = cellGroup.querySelector("use")
                if (existing) {
                    cellGroup.removeChild(existing);
                }
                const [value, ok] = this.get(x, y);
                if (ok) {
                    const symbol = value !== 0 ? "sun" : "moon";
                    cellGroup.appendChild(this.createSymbol(0, 0, 1.0, symbol, false));
                }
            }

            hint() {
                if (this.isSolved()) {
                    document.body.dataset.state = "solved";
                    if (this.confetti) {
                        confetti({
                            particleCount: 100,
                            spread: 70,
                            origin: { y: 1 }
                        });
                    }
                } else {
                    document.body.dataset.state = "playing";
                }
            }

            push() {
                this.future = [];
                this.history.push(this.current);
                this.setCurrent(this.currentState());
                this.loadState(this.current);
            }

            handleClick(x, y, right) {
                let next = 0;
                const [value, ok] = this.get(x, y);
                const state = ok ? value + 1 : 0;
                if (right) {
                    next = (state + 1) % 3;
                } else {
                    next = (state - 1 + 3) % 3;
                }

                if (next == 0) {
                    this.delete(x, y);
                } else {
                    this.set(x, y, next - 1);
                }
                this.updateCell(x, y);
                this.push();
            }

            undo() {
                if (this.history.length > 0) {
                    this.future.push(this.current);
                    this.setCurrent(this.history.pop());
                    this.loadState(this.current);
                }
            }

            redo() {
                if (this.future.length > 0) {
                    this.history.push(this.current);
                    this.setCurrent(this.future.pop());
                    this.loadState(this.current);
                }
            }

            createSymbol(x, y, scale, symbol, rotated) {
                const size = this.cellSize * scale;
                const xCoord = x * this.cellSize + (this.cellSize - size) / 2
                const yCoord = y * this.cellSize + (this.cellSize - size) / 2

                const use = document.createElementNS('http://www.w3.org/2000/svg', 'use');
                use.setAttribute('x', xCoord);
                use.setAttribute('y', yCoord);
                use.setAttribute('width', size);
                use.setAttribute('height', size);
                use.setAttribute('href', `#${symbol}`);
                use.setAttribute('pointer-events', 'none');
                if (rotated) {
                    use.setAttribute('transform', `rotate(90 ${xCoord + size / 2} ${yCoord + size / 2})`);
                }
                return use;
            };

            createBoard() {
                const widthSize = this.cellSize * 6;
                const heightSize = this.cellSize * 6;

                this.svgElement = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                this.svgElement.setAttribute('width', widthSize + 2);
                this.svgElement.setAttribute('height', heightSize + 2);
                this.svgElement.setAttribute('viewBox', `-1 -1 ${widthSize + 2} ${heightSize + 2}`);
                this.svgElement.setAttribute('version', '1.1');

                const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                this.svgElement.appendChild(defs);

                const symbols = {
                    sun: `<circle fill="#ffb31e" stroke="black" stroke-width="0.05" cx="0.5" cy="0.5" r="0.5"/>`,
                    moon: `<path fill="#82afed" stroke="black" stroke-width="0.05" d="m 0.7056 0.0444 a 0.5 0.5 90 0 1 0.0444 0.2056 a 0.5 0.5 90 0 1 -0.5 0.5 a 0.5 0.5 90 0 1 -0.2056 -0.0444 a 0.5 0.5 90 0 0 0.4556 0.2944 a 0.5 0.5 90 0 0 0.5 -0.5 a 0.5 0.5 90 0 0 -0.2944 -0.4556 z"/>`,
                    equal: `<path fill="black" stroke="#fff" stroke-width="0.1" stroke-linecap="round" paint-order="stroke" d="m 0.2 0.3 l 0.6 0 l 0 0.1 l -0.6 0 z m 0 0.3 l 0.6 0 l 0 0.1 l -0.6 0 z"/>`,
                    cross: `<path fill="black" stroke="#fff" stroke-width="0.1" stroke-linecap="round" paint-order="stroke" d="m 0.3232 0.2525 l 0.4243 0.4243 l -0.0707 0.0707 l -0.4243 -0.4243 z m -0.0707 0.4243 l 0.4243 -0.4243 l 0.0707 0.0707 l -0.4243 0.4243 z"/>`,
                };

                for (const [id, path] of Object.entries(symbols)) {
                    const symbol = document.createElementNS('http://www.w3.org/2000/svg', 'symbol');
                    symbol.setAttribute('id', id);
                    symbol.setAttribute('viewBox', '-1 -1 3 3');
                    symbol.innerHTML = path;
                    defs.appendChild(symbol);
                }


                for (let y = 0; y < 6; y++) {
                    for (let x = 0; x < 6; x++) {
                        const xCoord = x * this.cellSize;
                        const yCoord = y * this.cellSize;

                        const cellGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                        cellGroup.setAttribute('data-x', x);
                        cellGroup.setAttribute('data-y', y);
                        cellGroup.setAttribute('transform', `translate(${xCoord} ${yCoord})`);
                        this.svgElement.appendChild(cellGroup);

                        let fill = "white";
                        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        rect.setAttribute('width', this.cellSize);
                        rect.setAttribute('height', this.cellSize);
                        rect.setAttribute('fill', fill);
                        rect.setAttribute('stroke', 'black');
                        cellGroup.appendChild(rect);


                        const [value, ok] = this.get(x, y);
                        if (ok) {
                            const symbol = value !== 0 ? "sun" : "moon";
                            cellGroup.appendChild(this.createSymbol(0, 0, 1.0, symbol, false));
                            rect.setAttribute('fill', "#ddd");
                        } else {
                            cellGroup.addEventListener("contextmenu", (e) => {
                                e.preventDefault();
                                e.stopPropagation();
                                this.handleClick(x, y, true);
                            });
                            cellGroup.addEventListener("click", (e) => {
                                e.preventDefault();
                                e.stopPropagation();
                                this.handleClick(x, y, false);
                            });
                        }

                    }
                }

                for (let y = 0; y < 6; y++) {
                    for (let x = 0; x < 6; x++) {
                        const [rowValue, rowOk] = this.rowsConstr[y].get(x);
                        if (rowOk) {
                            const symbol = rowValue !== 0 ? "cross" : "equal";
                            this.svgElement.appendChild(this.createSymbol(x + 0.5, y, 0.8, symbol, false));
                        }

                        const [colValue, colOk] = this.colsConstr[x].get(y);
                        if (colOk) {
                            const symbol = colValue !== 0 ? "cross" : "equal";
                            this.svgElement.appendChild(this.createSymbol(x, y + 0.5, 0.8, symbol, true));
                        }
                    }
                }
            }

            checkConstraint(line, constr) {
                if (constr.mask === 0) {
                    return true;
                }
                const validA = line & 0b011111;
                const validS = line >> 1;
                return (((validA ^ validS ^ constr.value) & constr.mask) === 0);
            }

            countCompletions(line, constr) {
                let count = 0;
                for (const valid of [11, 13, 19, 21, 22, 25, 26, 37, 38, 41, 42, 44, 50, 52]) {
                    if (((line.value ^ valid) & line.mask) !== 0) {
                        continue;
                    }
                    if (!this.checkConstraint(valid, constr)) {
                        continue;
                    }
                    count++;
                }
                return count;
            }

            checkValidity() {
                for (let i = 0; i < 6; i++) {
                    if (this.countCompletions(this.rows[i], this.rowsConstr[i]) === 0) {
                        return ["row", i];
                    }
                    if (this.countCompletions(this.cols[i], this.colsConstr[i]) === 0) {
                        return ["col", i];
                    }
                }
                return [null, null];
            }

            isValid() {
                const [type, index] = this.checkValidity();
                return type === null
            }

            isSolved() {
                for (let y = 0; y < 6; y++) {
                    if (!this.rows[y].allSet()) {
                        return false;
                    }
                }
                return this.isValid();
            }
        }
        new Tango(document.querySelector(".game"));
    </script>
</body>

</html>