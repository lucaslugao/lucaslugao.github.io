<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no">
    <title>Tango - @lucaslugao</title>
    <style>
        body {
            font-family: sans-serif;
            text-align: center;
            height: 100vh;
            margin: 0;
        }

        .game {
            user-select: none;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            height: 100%;

            .controls {
                margin-bottom: 20px;
            }
        }
    </style>
</head>

<body>
    <div class="game">
        <div class="controls">
            <button class="undo">Undo</button>
            <button class="clear">Clear</button>
            <button class="redo">Redo</button>
        </div>
    </div>

    <script>
        class BitBuffer {
            constructor(base64String) {
                this.data = Array.from(this.base64ToUint8Array(base64String));
                this.bitIndex = 0;
            }

            base64ToUint8Array(base64String) {
                const binaryString = atob(base64String); //atob decodes base64
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return bytes;
            }

            readBits(numBits) {
                let result = 0;
                let readBits = 0;

                while (numBits > 0) {
                    const byteIndex = Math.floor(this.bitIndex / 8);
                    const bitOffset = this.bitIndex % 8;

                    const availableBits = 8 - bitOffset;
                    const readAmount = Math.min(numBits, availableBits);

                    if (byteIndex >= this.data.length) {
                        return 0;
                    }

                    const mask = (1 << readAmount) - 1;
                    const readVal = (this.data[byteIndex] >> bitOffset) & mask;

                    result |= readVal << readBits;
                    readBits += readAmount;
                    numBits -= readAmount;
                    this.bitIndex += readAmount;
                }

                return result;
            }

            writeBits(value, numBits) {
                value &= (1 << numBits) - 1;

                while (numBits > 0) {
                    const byteIndex = Math.floor(this.bitIndex / 8);
                    const bitOffset = this.bitIndex % 8;

                    if (byteIndex >= this.data.length) {
                        this.data.push(0);
                    }

                    const availableBits = 8 - bitOffset;
                    const writeBits = Math.min(numBits, availableBits);

                    const mask = ((1 << writeBits) - 1) << bitOffset;
                    const writeVal = (value << bitOffset);

                    this.data[byteIndex] = (this.data[byteIndex] & ~mask) | (writeVal & mask);

                    value >>= writeBits;
                    numBits -= writeBits;
                    this.bitIndex += writeBits;
                }
            }

        }
        class MaskedBitset {
            constructor(value = 0, mask = 0) {
                this.value = value;
                this.mask = mask;
            }

            set(k, v) {
                const bit = 1 << k;
                this.value = (this.value & ~bit) | ((-v & bit) >>> 0);
                this.mask |= bit;
            }

            has(k) {
                return (this.mask >> k) & 1 !== 0;
            }

            at(k) {
                return (this.value >> k) & 1;
            }

            get(k) {
                return [this.at(k), this.has(k)];
            }

            delete(k) {
                const bit = 1 << k;
                this.mask &= ~bit;
            }
        }
        class Tango {
            constructor(container, cellSize = 60) {
                this.cellSize = cellSize;
                this.container = container;

                const urlParams = new URLSearchParams(window.location.search);
                this.puzzle = urlParams.get('puzzle');
                if (!this.puzzle) {
                    window.location.search = `?puzzle=CIMgAEAQACAIAAAAAAAQAgAhIQAAAKAQ`;
                    return;
                }

                this.rows = Array(6).fill(null).map(() => new MaskedBitset());
                this.cols = Array(6).fill(null).map(() => new MaskedBitset());
                this.rowsConstr = Array(6).fill(null).map(() => new MaskedBitset());
                this.colsConstr = Array(6).fill(null).map(() => new MaskedBitset());

                const buf = new BitBuffer(this.puzzle);
                for (let k = 0; k < 6; k++) {
                    this.setRow(k, new MaskedBitset(buf.readBits(6), buf.readBits(6)));
                }
                for (let k = 0; k < 6; k++) {
                    this.rowsConstr[k].value = buf.readBits(5);
                    this.rowsConstr[k].mask = buf.readBits(5);
                    this.colsConstr[k].value = buf.readBits(5);
                    this.colsConstr[k].mask = buf.readBits(5);
                }
                this.createBoard();
                this.loadState(decodeURIComponent(window.location.hash.substring(1)));
                this.setCurrent(this.currentState());
                this.history = [];
                this.future = [];

                this.container.appendChild(this.svgElement);

                this.container.querySelector(".undo").addEventListener("click", () => {
                    this.undo();
                });
                this.container.querySelector(".redo").addEventListener("click", () => {
                    this.redo();
                });
                this.container.querySelector(".clear").addEventListener("click", () => {
                    this.clear();
                });
            }

            clear() {
                this.loadState(this.puzzle);
                this.push();
            }

            set(x, y, c) {
                this.cols[x].set(y, c);
                this.rows[y].set(x, c);
            }

            get(x, y) {
                return this.rows[y].get(x);
            }

            has(x, y) {
                return this.rows[y].has(x);
            }

            delete(x, y) {
                this.rows[y].delete(x);
                this.cols[x].delete(y);
            }

            setRow(y, row) {
                this.rows[y] = row;

                for (let x = 0; x < 6; x++) {
                    const [v, ok] = row.get(x);
                    if (ok) {
                        this.cols[x].set(y, v);
                    }
                }
            }

            loadState(current) {
                if (!current) {
                    return;
                }
                const currentBuf = new BitBuffer(current);
                for (let k = 0; k < 6; k++) {
                    this.setRow(k, new MaskedBitset(currentBuf.readBits(6), currentBuf.readBits(6)));
                }
                for (let y = 0; y < 6; y++) {
                    for (let x = 0; x < 6; x++) {
                        this.updateCell(x, y);
                    }
                }
            }
            setCurrent(state) {
                this.current = state;
                window.location.hash = encodeURIComponent(this.current);

            }

            currentState() {
                const buf = new BitBuffer("");
                for (let k = 0; k < 6; k++) {
                    const row = this.rows[k];
                    buf.writeBits(row.value, 6);
                    buf.writeBits(row.mask, 6);
                }
                return btoa(String.fromCharCode(...buf.data));
            }

            updateCell(x, y) {
                const cellGroup = this.svgElement.querySelector(`[data-x="${x}"][data-y="${y}"]`);
                const existing = cellGroup.querySelector("use")
                if (existing) {
                    cellGroup.removeChild(existing);
                }
                const [value, ok] = this.get(x, y);
                if (ok) {
                    const symbol = value !== 0 ? "sun" : "moon";
                    cellGroup.appendChild(this.createSymbol(0, 0, 1.0, symbol, false));
                }
            }

            push() {
                this.future = [];
                this.history.push(this.current);
                this.setCurrent(this.currentState());
            }

            handleClick(x, y, right) {
                let next = 0;
                const [value, ok] = this.get(x, y);
                const state = ok ? value + 1 : 0;
                if (right) {
                    next = (state + 1) % 3;
                } else {
                    next = (state - 1 + 3) % 3;
                }

                if (next == 0) {
                    this.delete(x, y);
                } else {
                    this.set(x, y, next - 1);
                }
                this.updateCell(x, y);
                this.push();
            }

            undo() {
                if (this.history.length > 0) {
                    this.future.push(this.current);
                    this.setCurrent(this.history.pop());
                    this.loadState(this.current);
                }
                console.log({
                    future: this.future,
                    history: this.history
                });
            }

            redo() {
                if (this.future.length > 0) {
                    this.history.push(this.current);
                    this.setCurrent(this.future.pop());
                    this.loadState(this.current);
                }
                console.log({
                    future: this.future,
                    history: this.history
                });
            }

            createSymbol(x, y, scale, symbol, rotated) {
                const size = this.cellSize * scale;
                const xCoord = x * this.cellSize + (this.cellSize - size) / 2
                const yCoord = y * this.cellSize + (this.cellSize - size) / 2

                const use = document.createElementNS('http://www.w3.org/2000/svg', 'use');
                use.setAttribute('x', xCoord);
                use.setAttribute('y', yCoord);
                use.setAttribute('width', size);
                use.setAttribute('height', size);
                use.setAttribute('href', `#${symbol}`);
                use.setAttribute('pointer-events', 'none');
                if (rotated) {
                    use.setAttribute('transform', `rotate(90 ${xCoord + size / 2} ${yCoord + size / 2})`);
                }
                return use;
            };

            createBoard() {
                const widthSize = this.cellSize * 6;
                const heightSize = this.cellSize * 6;

                this.svgElement = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                this.svgElement.setAttribute('width', widthSize + 2);
                this.svgElement.setAttribute('height', heightSize + 2);
                this.svgElement.setAttribute('viewBox', `-1 -1 ${widthSize + 2} ${heightSize + 2}`);
                this.svgElement.setAttribute('version', '1.1');

                const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                this.svgElement.appendChild(defs);

                const symbols = {
                    sun: `<circle fill="#ffb31e" stroke="black" stroke-width="0.05" cx="0.5" cy="0.5" r="0.5"/>`,
                    moon: `<path fill="#82afed" stroke="black" stroke-width="0.05" d="m 0.7056 0.0444 a 0.5 0.5 90 0 1 0.0444 0.2056 a 0.5 0.5 90 0 1 -0.5 0.5 a 0.5 0.5 90 0 1 -0.2056 -0.0444 a 0.5 0.5 90 0 0 0.4556 0.2944 a 0.5 0.5 90 0 0 0.5 -0.5 a 0.5 0.5 90 0 0 -0.2944 -0.4556 z"/>`,
                    equal: `<path fill="black" stroke="#fff" stroke-width="0.1" stroke-linecap="round" paint-order="stroke" d="m 0.2 0.3 l 0.6 0 l 0 0.1 l -0.6 0 z m 0 0.3 l 0.6 0 l 0 0.1 l -0.6 0 z"/>`,
                    cross: `<path fill="black" stroke="#fff" stroke-width="0.1" stroke-linecap="round" paint-order="stroke" d="m 0.3232 0.2525 l 0.4243 0.4243 l -0.0707 0.0707 l -0.4243 -0.4243 z m -0.0707 0.4243 l 0.4243 -0.4243 l 0.0707 0.0707 l -0.4243 0.4243 z"/>`,
                };

                for (const [id, path] of Object.entries(symbols)) {
                    const symbol = document.createElementNS('http://www.w3.org/2000/svg', 'symbol');
                    symbol.setAttribute('id', id);
                    symbol.setAttribute('viewBox', '-1 -1 3 3');
                    symbol.innerHTML = path;
                    defs.appendChild(symbol);
                }


                for (let y = 0; y < 6; y++) {
                    for (let x = 0; x < 6; x++) {
                        const xCoord = x * this.cellSize;
                        const yCoord = y * this.cellSize;

                        const cellGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                        cellGroup.setAttribute('data-x', x);
                        cellGroup.setAttribute('data-y', y);
                        cellGroup.setAttribute('transform', `translate(${xCoord} ${yCoord})`);
                        this.svgElement.appendChild(cellGroup);

                        let fill = "white";
                        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        rect.setAttribute('width', this.cellSize);
                        rect.setAttribute('height', this.cellSize);
                        rect.setAttribute('fill', fill);
                        rect.setAttribute('stroke', 'black');
                        cellGroup.appendChild(rect);


                        const [value, ok] = this.get(x, y);
                        if (ok) {
                            const symbol = value !== 0 ? "sun" : "moon";
                            cellGroup.appendChild(this.createSymbol(0, 0, 1.0, symbol, false));
                            rect.setAttribute('fill', "#ddd");
                        } else {
                            cellGroup.addEventListener("contextmenu", (e) => {
                                e.preventDefault();
                                e.stopPropagation();
                                this.handleClick(x, y, true);
                            });
                            cellGroup.addEventListener("click", (e) => {
                                e.preventDefault();
                                e.stopPropagation();
                                this.handleClick(x, y, false);
                            });
                        }

                    }
                }

                for (let y = 0; y < 6; y++) {
                    for (let x = 0; x < 6; x++) {
                        const [rowValue, rowOk] = this.rowsConstr[y].get(x);
                        if (rowOk) {
                            const symbol = rowValue !== 0 ? "cross" : "equal";
                            this.svgElement.appendChild(this.createSymbol(x + 0.5, y, 0.8, symbol, false));
                        }

                        const [colValue, colOk] = this.colsConstr[x].get(y);
                        if (colOk) {
                            const symbol = colValue !== 0 ? "cross" : "equal";
                            this.svgElement.appendChild(this.createSymbol(x, y + 0.5, 0.8, symbol, true));
                        }
                    }
                }
            }
        }

        new Tango(document.querySelector(".game"));
    </script>
</body>

</html>